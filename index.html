<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hypnotic Particle Field</title>
  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 20% 20%, #0d1020, #020208 65%);
      color: #f2f5ff;
      overflow: hidden;
    }

    body {
      position: relative;
    }

    .scene-container {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .ui-overlay {
      position: fixed;
      top: 2.5rem;
      left: 2.5rem;
      max-width: 22rem;
      line-height: 1.6;
      letter-spacing: 0.04em;
      font-size: 0.82rem;
      text-transform: uppercase;
      pointer-events: none;
      opacity: 0.75;
    }

    .ui-overlay h1 {
      margin: 0 0 0.35rem;
      font-size: 0.92rem;
      letter-spacing: 0.2em;
      font-weight: 600;
    }

    .ui-overlay p {
      margin: 0;
    }

    .lil-gui {
      --background-color: rgba(12, 12, 28, 0.76);
      --text-color: #f5f8ff;
      --title-background-color: rgba(29, 36, 71, 0.9);
      --widget-color: rgba(26, 32, 60, 0.9);
      --hover-color: rgba(70, 98, 166, 0.9);
      --focus-color: rgba(130, 156, 220, 0.9);
      font-family: "Inter", "Segoe UI", sans-serif;
      border-radius: 10px;
      overflow: hidden;
    }

    .lil-gui.root {
      position: fixed;
      right: 24px;
      top: 24px;
    }

    .lil-gui .title {
      letter-spacing: 0.1em;
    }

    @media (max-width: 768px) {
      .ui-overlay {
        left: 1.5rem;
        right: 1.5rem;
        max-width: 100%;
        font-size: 0.75rem;
      }

      .lil-gui.root {
        right: auto;
        left: 50%;
        transform: translateX(-50%);
        top: auto;
        bottom: 1rem;
      }
    }
  </style>
</head>
<body>
  <div class="scene-container"></div>
  <div class="ui-overlay">
    <h1>Hypnotic Field</h1>
    <p>
      Drift your pointer to bend the waves. Click or tap to launch ripples.
      Use the control panel for endless variations.
    </p>
  </div>
  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.157/build/three.module.js";
    import Stats from "https://threejs.org/examples/jsm/libs/stats.module.js";
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm";

    const SEPARATION = 90;
    const AMOUNTX = 70;
    const AMOUNTY = 70;

    const halfGridX = ((AMOUNTX - 1) * SEPARATION) / 2;
    const halfGridY = ((AMOUNTY - 1) * SEPARATION) / 2;

    let container;
    let camera;
    let scene;
    let renderer;
    let stats;
    let gui;
    let particles;

    const clock = new THREE.Clock();
    let elapsedTime = 0;
    let animationTime = 0;
    let autoAngle = 0;

    const pointer = {
      x: 0,
      y: 0,
      worldX: 0,
      worldZ: 0,
      energy: 0
    };

    const ripples = [];

    const uniforms = {
      opacity: { value: 0.88 },
      pointMultiplier: { value: 18 }
    };

    const settings = {
      amplitude: 80,
      waveXFrequency: 0.22,
      waveYFrequency: 0.28,
      swirlStrength: 1.35,
      swirlFrequency: 0.006,
      animationSpeed: 0.42,
      colorCycleSpeed: 0.035,
      colorSpread: 0.35,
      pointSize: 18,
      mouseInfluence: 0.0045,
      rippleStrength: 70,
      rippleSpeed: 360,
      rippleWidth: 18,
      rippleDecay: 0.0022,
      opacity: 0.88,
      autoRotate: true,
      showStats: false
    };

    init();
    animate();

    function init() {
      container = document.querySelector(".scene-container");

      camera = new THREE.PerspectiveCamera(58, window.innerWidth / window.innerHeight, 1, 5000);
      camera.position.set(0, 420, 1600);

      scene = new THREE.Scene();
      const backgroundColor = new THREE.Color(0x050513);
      scene.background = backgroundColor;
      scene.fog = new THREE.FogExp2(backgroundColor, 0.00085);

      const numParticles = AMOUNTX * AMOUNTY;
      const positions = new Float32Array(numParticles * 3);
      const scales = new Float32Array(numParticles);
      const colors = new Float32Array(numParticles * 3);

      let i = 0;
      let j = 0;

      for (let ix = 0; ix < AMOUNTX; ix++) {
        for (let iy = 0; iy < AMOUNTY; iy++) {
          positions[i] = ix * SEPARATION - halfGridX; // x
          positions[i + 1] = 0; // y
          positions[i + 2] = iy * SEPARATION - halfGridY; // z

          scales[j] = 1;

          colors[j * 3] = 1;
          colors[j * 3 + 1] = 1;
          colors[j * 3 + 2] = 1;

          i += 3;
          j++;
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute("scale", new THREE.BufferAttribute(scales, 1));
      geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      const material = new THREE.ShaderMaterial({
        uniforms,
        vertexShader: /* glsl */ `
          attribute float scale;
          attribute vec3 color;
          varying vec3 vColor;

          uniform float pointMultiplier;

          void main() {
            vColor = color;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = scale * pointMultiplier * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: /* glsl */ `
          varying vec3 vColor;
          uniform float opacity;

          void main() {
            vec2 delta = gl_PointCoord - vec2(0.5);
            float dist = dot(delta, delta);
            if (dist > 0.25) discard;
            float falloff = smoothstep(0.25, 0.0, dist);
            gl_FragColor = vec4(vColor, falloff * opacity);
          }
        `,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });

      particles = new THREE.Points(geometry, material);
      particles.frustumCulled = false;
      scene.add(particles);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      container.appendChild(renderer.domElement);

      stats = new Stats();
      stats.dom.style.display = "none";
      container.appendChild(stats.dom);

      container.style.touchAction = "none";
      container.addEventListener("pointermove", onPointerMove);
      container.addEventListener("pointerdown", onPointerDown);
      container.addEventListener("pointerleave", onPointerLeave);

      window.addEventListener("resize", onWindowResize);

      buildGui();
    }

    function buildGui() {
      gui = new GUI({ title: "Field Controls" });

      const waveFolder = gui.addFolder("Waves");
      waveFolder.add(settings, "amplitude", 20, 160, 1);
      waveFolder.add(settings, "waveXFrequency", 0.05, 0.5, 0.005).name("Frequency X");
      waveFolder.add(settings, "waveYFrequency", 0.05, 0.5, 0.005).name("Frequency Y");
      waveFolder.add(settings, "swirlStrength", 0, 3, 0.01);
      waveFolder.add(settings, "swirlFrequency", 0.001, 0.02, 0.0005).name("Swirl Scale");
      waveFolder.add(settings, "animationSpeed", 0.05, 1.2, 0.01).name("Flow Speed");

      const colorFolder = gui.addFolder("Color");
      colorFolder.add(settings, "colorCycleSpeed", 0, 0.15, 0.001).name("Cycle Speed");
      colorFolder.add(settings, "colorSpread", 0.05, 0.8, 0.01).name("Color Spread");
      colorFolder.add(settings, "opacity", 0.3, 1, 0.01).name("Glow").onChange((value) => {
        uniforms.opacity.value = value;
      });

      const interactionFolder = gui.addFolder("Interaction");
      interactionFolder.add(settings, "mouseInfluence", 0.001, 0.02, 0.0005).name("Pointer Warp");
      interactionFolder.add(settings, "rippleStrength", 10, 150, 1).name("Ripple Strength");
      interactionFolder.add(settings, "rippleSpeed", 80, 600, 5).name("Ripple Speed");
      interactionFolder.add(settings, "rippleWidth", 4, 40, 0.1).name("Ripple Wavelength");
      interactionFolder.add(settings, "rippleDecay", 0.0005, 0.01, 0.0001).name("Ripple Fade");
      interactionFolder.add(settings, "autoRotate");
      interactionFolder.add(settings, "showStats").name("Show Stats").onChange((value) => {
        stats.dom.style.display = value ? "block" : "none";
      });

      gui.add(settings, "pointSize", 6, 30, 0.5).name("Point Scale").onChange((value) => {
        uniforms.pointMultiplier.value = value;
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onPointerMove(event) {
      if (!event.isPrimary) return;

      const normalizedX = (event.clientX / window.innerWidth) * 2 - 1;
      const normalizedY = (event.clientY / window.innerHeight) * 2 - 1;

      const deltaX = normalizedX - pointer.x;
      const deltaY = normalizedY - pointer.y;

      pointer.x = normalizedX;
      pointer.y = normalizedY;
      pointer.worldX = pointer.x * halfGridX;
      pointer.worldZ = pointer.y * halfGridY;
      pointer.energy = Math.min(pointer.energy + Math.abs(deltaX) + Math.abs(deltaY), 2.0);
    }

    function onPointerDown(event) {
      if (!event.isPrimary) return;

      const rect = renderer.domElement.getBoundingClientRect();
      const normX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      const normY = ((event.clientY - rect.top) / rect.height) * 2 - 1;

      const rippleX = normX * halfGridX;
      const rippleZ = normY * halfGridY;

      ripples.push({ x: rippleX, z: rippleZ, start: elapsedTime });
      if (ripples.length > 8) {
        ripples.shift();
      }

      pointer.energy = Math.min(pointer.energy + 0.6, 2.2);
    }

    function onPointerLeave() {
      pointer.x = 0;
      pointer.y = 0;
      pointer.worldX = 0;
      pointer.worldZ = 0;
    }

    function animate() {
      requestAnimationFrame(animate);
      render();
    }

    function render() {
      const delta = clock.getDelta();
      elapsedTime += delta;
      animationTime += delta * settings.animationSpeed;

      if (settings.autoRotate) {
        autoAngle += delta * 0.12;
      }

      pointer.energy *= 0.96;

      const positions = particles.geometry.attributes.position.array;
      const scales = particles.geometry.attributes.scale.array;
      const colors = particles.geometry.attributes.color.array;
      const color = new THREE.Color();

      let i = 0;
      let j = 0;

      for (let ix = 0; ix < AMOUNTX; ix++) {
        for (let iy = 0; iy < AMOUNTY; iy++) {
          const px = ix * SEPARATION - halfGridX;
          const pz = iy * SEPARATION - halfGridY;
          const radial = Math.sqrt(px * px + pz * pz);

          let height = 0;
          height += Math.sin(ix * settings.waveXFrequency + animationTime) * settings.amplitude;
          height += Math.cos(iy * settings.waveYFrequency - animationTime * 1.3) * settings.amplitude * 0.65;
          height += Math.sin(radial * settings.swirlFrequency - animationTime * 1.6) * settings.swirlStrength * settings.amplitude * 0.45;

          const dxMouse = px - pointer.worldX;
          const dzMouse = pz - pointer.worldZ;
          const mouseDist = Math.sqrt(dxMouse * dxMouse + dzMouse * dzMouse) + 0.0001;
          const mouseEnvelope = Math.exp(-mouseDist * settings.mouseInfluence * 0.65);
          height += Math.cos(mouseDist * settings.mouseInfluence * 16 - animationTime * 2.6) * pointer.energy * settings.amplitude * 0.5 * mouseEnvelope;

          for (let r = ripples.length - 1; r >= 0; r--) {
            const ripple = ripples[r];
            const age = elapsedTime - ripple.start;
            if (age > 6) {
              ripples.splice(r, 1);
              continue;
            }
            const dist = Math.sqrt((px - ripple.x) * (px - ripple.x) + (pz - ripple.z) * (pz - ripple.z)) + 0.0001;
            const wavefront = age * settings.rippleSpeed;
            const envelope = Math.exp(-dist * settings.rippleDecay) * Math.exp(-age * 0.65);
            height += Math.sin((dist - wavefront) / settings.rippleWidth) * settings.rippleStrength * envelope;
          }

          positions[i + 1] = height;

          const heightNormalized = THREE.MathUtils.clamp(0.5 + height * 0.0016, 0, 1);
          scales[j] = 0.7 + heightNormalized * 2.0;

          const hue = (animationTime * settings.colorCycleSpeed + radial * 0.00042 + heightNormalized * settings.colorSpread) % 1;
          color.setHSL(hue, 0.62 + 0.15 * (1 - heightNormalized), 0.35 + 0.4 * heightNormalized);

          const ci = j * 3;
          colors[ci] = color.r;
          colors[ci + 1] = color.g;
          colors[ci + 2] = color.b;

          i += 3;
          j++;
        }
      }

      particles.geometry.attributes.position.needsUpdate = true;
      particles.geometry.attributes.scale.needsUpdate = true;
      particles.geometry.attributes.color.needsUpdate = true;

      uniforms.pointMultiplier.value = settings.pointSize;
      uniforms.opacity.value = settings.opacity;

      const orbitRadius = 1200;
      const baseX = Math.cos(autoAngle) * orbitRadius;
      const baseZ = Math.sin(autoAngle) * orbitRadius * 0.75 + 1400;
      const targetX = baseX + pointer.x * 260;
      const targetY = 360 + pointer.y * 220;
      const targetZ = baseZ + pointer.y * -80;

      camera.position.x += (targetX - camera.position.x) * 0.045;
      camera.position.y += (targetY - camera.position.y) * 0.05;
      camera.position.z += (targetZ - camera.position.z) * 0.035;
      camera.lookAt(scene.position);

      renderer.render(scene, camera);

      if (settings.showStats) {
        stats.update();
      }
    }
  </script>
</body>
</html>
